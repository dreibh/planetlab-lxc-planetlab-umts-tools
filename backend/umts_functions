#!/bin/bash


STROK="remote IP address"
GCOMP="comgt"
GCOM="/usr/bin/"${GCOMP}
LOGF="/tmp/umtslogs"
PPPD_PIDFILE="/var/run/umts_pppd.pid"
DESTS_FILE="/tmp/umts_dest_file"
FILE_TEMP_NID="/tmp/umts_temp_nid"
FILE_UMTS_INT="/tmp/umts_dev"
LOCK_DIR="/tmp/umts_lock_d"
FILE_LOCK_SLIVER="/tmp/umts_locking_sliver"
PPP_INT="ppp0"
PPPD="pppd"
CHAT_SCRIPTS="/etc/chatscripts"
UMTS_CONF="/etc/umts.conf"



function get_umts_dev(){
	echo "/dev/umts_modem"
}

function init_umts(){
	#local found=1
	
	if [ -e $LOCK_DIR ]; then
		rmdir $LOCK_DIR
	fi

	# the routing table is now managed by sliceip
	#if ! grep "umts_table" /etc/iproute2/rt_tables > /dev/null 2>&1; then
	#	echo "20 umts_table" >> /etc/iproute2/rt_tables
	#fi

	return 0

}


function get_temp_nid(){
	cat $FILE_TEMP_NID
}


#called when the connection is started
function conn_on(){
	local sliver=$1

	#DESTS_FILE contains added destinations
	rm -f $DESTS_FILE 

	cat $LOGF | grep "local"
	return 0

}

#called when the connection is terminated to remove the rules
#on the destinations reachable thorugh the UMTS device
function conn_off(){
	local sliver=$1
	local ppp_addr=$2

# Not needed anymore as the killing of the PPP connection
# makes the rules pointing to it automatically disappear.

#	for i in `cat $DESTS_FILE`; do
#		del_destination $i $sliver > /dev/null 2>&1
#	done

	rm $DESTS_FILE >/dev/null 2>&1
}

function start_umts(){
    local sliver=$1
    local sliver_nid=`get_nid $sliver`

    if ! lock $sliver; then
	return 1
    fi	

    if status_umts; then
	 echo "Already connected"
	 return 0; 
    fi
    
    echo "Starting GCOM..."
    if ! $GCOM -d `get_umts_dev`; then
	unlock $sliver
	return 1
    fi

    rm -f $LOGF

    if [ -e $UMTS_CONF ]; then
    	. $UMTS_CONF
    fi
 
    if ! [[ $APN ]]; then
	APN="web.omnitel.it"
    fi
    if ! [[ $NUM ]]; then
        NUM="*99***1#"
    fi
    

    exec /usr/sbin/pppd nodetach `get_umts_dev` 460800 \
        	0.0.0.0:0.0.0.0 \
        	connect "/usr/sbin/chat -v                     \
        	TIMEOUT         6                              \
        	ABORT           '\nBUSY\r'                     \
        	ABORT           '\nNO ANSWER\r'                \
        	ABORT           '\nRINGING\r\n\r\nRINGING\r'   \
        	''              ATZ     OK 'ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0' OK  \
        	'AT+CGDCONT=1,\"IP\",\"$APN\"' OK \
		ATD$NUM   CONNECT ''" > $LOGF &


    echo $! > $PPPD_PIDFILE

    sleep 5s;  #waiting for the interface to establish the link
    if grep "$STROK" $LOGF >/dev/null 2>&1; then
	conn_on $sliver $sliver_nid
    else
	#second try
	sleep 5s;
	if grep "$STROK" $LOGF >/dev/null 2>&1; then
	    conn_on $sliver $sliver_nid
	else
	    stop_umts $sliver
	    return 1
	fi
    fi
}


# stop the UMTS connection by killing the pppd daemon and
# then by calling conn_off
function stop_umts(){
    local sliver=$1
    local sliver_nid=`get_nid $sliver`
    local ppp_addr

    if ! [ -e $PPPD_PIDFILE ]; then 
	echo "Disconnected"
	return 0;
    fi

    ppp_addr=`get_ppp_address`

    if ! check_who_locked $sliver; then
	return 1
    fi

    PID=`cat $PPPD_PIDFILE`;

    if [ -d /proc/$PID ] &&  grep $PPPD /proc/$PID/cmdline >/dev/null 2>&1; then 	
	kill $PID;	
	touch $DESTS_FILE
	sleep 2s;
    fi

    if status_umts; then
	return 1;
    else
	conn_off $sliver $ppp_addr
	cat $LOGF | grep "time"
	rm $PPPD_PIDFILE
	unlock $sliver;
	return 0
    fi
}

# check the status of the umts connection by looking at then
# state of pppd daemon
function status_umts(){
    local sliver=$1
	
    if ! [ -e $PPPD_PIDFILE ]; then return 1; fi
    PID=`cat $PPPD_PIDFILE`

    if [ -d /proc/$PID ] &&  grep $PPPD /proc/$PID/cmdline >/dev/null 2>&1; then
        return 0;
    else 
	return 1;
    fi
}

#add the ppp interface to the slice - not used at the moment
function add_interface(){
    local nid=`get_nid $1`
    $NADDRESS --add --nid $nid --ip $PPP_INT >>$LOGFILE 2>&1;
}

#remove the ppp interface from the slice - not used at the moment
function del_interface(){
    local nid=`get_nid $1`
    #$NADDRESS --remove --nid $NID --ip $PPP_INT >>$LOGFILE 2>&1;
}

#get slice network id
function get_nid(){
    id -u ${1}
}


# check if sliceip is activated for the slice
function check_sliceip(){
  
  if ! [ -e /vsys/sliceip ]; then
    echo "Sliceip is not installed. Exiting."
    return 1
  fi
  
}

# Deliver a command to sliceip (basically to set the destinations to be
# reached through the UMTS device)
function sliceip_cmd(){

  local command=$2
  local sliver=$1
  
  echo "$command" | /vsys/sliceip $sliver
  
}

# Add a destination to be reached through the UMTS device
function add_destination(){
	local dest="$1"
	local sliver=$2

	if [[ ! $dest ]]; then return 1; fi

	if ! status_umts; then
		return 1;
	fi

	if ! check_who_locked $sliver; then
		return 1;
	fi

	sliceip_cmd $sliver "route add $dest dev ${PPP_INT}"	
	  
}

# Delete a destination that was previously reached through the UMTS device.
function del_destination(){
	local dest="$1"
	local sliver=$2
	
	if [[ ! $dest ]]; then return 1; fi

	if ! check_who_locked $sliver; then
		return 1;
	fi

	sliceip_cmd $sliver "route del $dest dev ${PPP_INT}";

}


function get_ppp_address(){
	ifconfig $PPP_INT | grep inet\ addr | cut -d ":" -f 2 | cut -d " " -f 1
}


function check_who_locked(){
	local sliver=$1
	local sliver_nid=`get_nid $sliver`
	local ret=0

	if [ -e $LOCK_DIR ]; then
 		if [[ `cat $FILE_LOCK_SLIVER` != $sliver_nid ]]; then
			echo "Interface in use by another slice.";
			ret=1
		fi
	else
		ret=1
	fi

	return $ret

}

# kill the gcom daemon
function kill_gcom(){
	
	killall $GCOMP
	sleep 3
	if ! ps -C $GCOMP >/dev/null 2>&1; then
		echo "$GCOMP terminated."	
	else 
		echo "$GCOMP still alive. Try kill -9"
		sleep 2

		killall -9 $GCOMP
	
		if ! ps -C $GCOMP >/dev/null 2>&1; then
			echo "$GCOMP terminated."
		else		
			echo "Couldn't stop $GCOMP. Please contact administrators for assistance."	
		fi
	fi
}

# lock the umts connection to a specific sliver.
# only one sliver at a given time can use the UMTS device
function lock(){
	local sliver=$1
# 	local sliver_nid=`get_nid $sliver`
	local ret=0

	if [ -e $LOCK_DIR ]; then
 		if ! check_who_locked $sliver; then
			ret=1
		fi
	else 
		if mkdir $LOCK_DIR >/dev/null 2>&1; then
			echo "$sliver_nid" > $FILE_LOCK_SLIVER
		else
			ret=1
		fi
	fi

	return $ret
}

function unlock(){
	local sliver=$1
	local sliver_nid=`get_nid $sliver`
	local ret=0

	if ! [ -e $LOCK_DIR ]; then
		ret=1
	else 
		if ! check_who_locked $sliver; then
			ret=1
		else
			if ! rmdir $LOCK_DIR; then
				ret=1
			fi
		fi	
	fi

	return $ret
}




# checks an ip addresse for validity
function valid_dotted_quad(){
    oldIFS=$IFS
    IFS=.
    set -f
    set -- $1
    if [ $# -eq 4 ]
    then
      for seg
      do
        case $seg in
            ""|*[!0-9]*) return 1; break ;; ## Segment empty or non-numeric char
            *) [ $seg -gt 255 ] && return 2 ;;
        esac
      done
    else
      return 3 ## Not 4 segments
    fi
    IFS=$oldIFS
    set +f
    return 0;
}

